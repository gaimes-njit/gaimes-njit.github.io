"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printGrid = exports.initializeGrid = exports.getGridContentHeight = exports.getGridContentWidth = exports.getBlockPositionOnGrid = exports.getBlocksWithPosition = exports.shiftBlocksOnGrid = exports.getHighestBlock = exports.getRightMostBlock = exports.getLeftMostBlock = exports.STRUCTURE_STARTING_POSITION = exports.LEVEL_WIDTH_IN_UNITY = exports.ONE_CELL_WIDTH_IN_UNITY = exports.FUNCTION_PREFIX = exports.GRID_HEIGHT = exports.GRID_WIDTH = void 0;
const index_1 = require("./models/index");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const position_1 = require("./models/position");
/**
 * Width of the grid
 */
exports.GRID_WIDTH = 20;
/**
 * Height of the grid
 */
exports.GRID_HEIGHT = 16;
/**
 * Function prefix for `ab_drop` function calls
 */
exports.FUNCTION_PREFIX = 'ab_drop(';
/**
 * Width of the one cell of a grid in Unity
 */
exports.ONE_CELL_WIDTH_IN_UNITY = new bignumber_js_1.default('0.2401');
/**
 * Level width in Unity
 */
exports.LEVEL_WIDTH_IN_UNITY = new bignumber_js_1.default('18');
/**
 * Structure starting position in Unity
 */
exports.STRUCTURE_STARTING_POSITION = new position_1.Position(new bignumber_js_1.default('2'), new bignumber_js_1.default('-3.5'));
/**
 * This function is used to get the left most block from the array of blocks
 * @param blocks array of blocks to get the left most block from
 * @returns the left most block
 */
function getLeftMostBlock(blocks) {
    let leftMostBlock = blocks[0];
    for (const block of blocks) {
        if (block.position.x.isLessThan(leftMostBlock.position.x)) {
            leftMostBlock = block;
        }
    }
    return leftMostBlock;
}
exports.getLeftMostBlock = getLeftMostBlock;
/**
 * This function is used to get the right most block from the array of blocks
 * @param blocks array of blocks to get the right most block from
 * @returns the right most block
 */
function getRightMostBlock(blocks) {
    let rightMostBlock = blocks[0];
    for (const block of blocks) {
        if (block.position.x.isGreaterThan(rightMostBlock.position.x)) {
            rightMostBlock = block;
        }
    }
    return rightMostBlock;
}
exports.getRightMostBlock = getRightMostBlock;
/**
 * This function is used to get the top most block from the array of blocks
 * @param blocks array of blocks to get the top most block from
 * @returns the top most block
 */
function getHighestBlock(blocks) {
    let highestBlock = blocks[0];
    for (const block of blocks) {
        if (block.position.y.isGreaterThan(highestBlock.position.y)) {
            highestBlock = block;
        }
    }
    return highestBlock;
}
exports.getHighestBlock = getHighestBlock;
/**
 * This function is used to shift blocks to the left most position on the grid
 * @param blocks array of blocks to shift to the left most position

* @param grid grid represents the placement of the blocks
 * @returns an array of blocks shifted to the left most position and the updated grid
 */
function shiftBlocksOnGrid(blocks, grid) {
    const newGrid = grid.map((row) => [...row]);
    let shiftAmount = newGrid[0].length;
    for (let i = 0; i < newGrid[0].length; i++) {
        for (const row of newGrid) {
            if (row[i] !== 0) {
                shiftAmount = Math.min(shiftAmount, i);
            }
        }
    }
    for (const block of blocks) {
        block.position.x = block.position.x.minus(shiftAmount);
    }
    for (let i = 0; i < newGrid.length; i++) {
        newGrid[i] = newGrid[i].slice(shiftAmount);
        for (let j = 0; j < shiftAmount; j++) {
            newGrid[i].push(0);
        }
    }
    return [blocks, newGrid];
}
exports.shiftBlocksOnGrid = shiftBlocksOnGrid;
/**
 * This function is used to get the blocks with their positions on the grid
 * @param functionsString string of `ab_drop()` functions
 * @returns an array of `Block`'s blocks with their positions on the grid
 */
function getBlocksWithPosition(functionsString) {
    const blocks = [];
    let grid = initializeGrid(exports.GRID_WIDTH, exports.GRID_HEIGHT);
    const lines = functionsString.split('\n');
    for (const line of lines) {
        if (line.substring(0, exports.FUNCTION_PREFIX.length) !== exports.FUNCTION_PREFIX) {
            continue;
        }
        const blockType = getBlockTypeFromLine(line);
        const slotPosition = getSlotPositionFromLine(line);
        const block = index_1.Block.getAvailableBlock(blockType);
        const position = getBlockPositionOnGrid(blockType, slotPosition, grid);
        grid = placeBlockOnGrid(grid, position, slotPosition, block.size);
        block.position = new position_1.Position(new bignumber_js_1.default(position.x), new bignumber_js_1.default(position.y));
        blocks.push(block);
    }
    return [blocks, grid];
}
exports.getBlocksWithPosition = getBlocksWithPosition;
/**
 * This function is used to get the block type from the line of `ab_drop()` function
 * @param line line of `ab_drop()` function
 * @returns the block type of the block
 */
function getBlockTypeFromLine(line) {
    const commaIndex = line.indexOf(',');
    const extractedBlockType = line.substring(exports.FUNCTION_PREFIX.length + 1, commaIndex - 1).toUpperCase();
    const blockType = index_1.BlockType[extractedBlockType];
    return blockType;
}
/**
 * This function is used to get the slot position from the line of `ab_drop()` function
 * @param line line of `ab_drop()` function
 * @returns the slot position of the block
 */
function getSlotPositionFromLine(line) {
    const commaIndex = line.indexOf(',');
    const extractedSlotPosition = line
        .substring(commaIndex + 1)
        .split(')')[0]
        .trim();
    const slotPosition = parseInt(extractedSlotPosition, 10);
    return slotPosition;
}
/**
 * This function is used to get the block position on the grid
 * @param blockType block type
 * @param slotPosition slot position
 * @param grid grid represents the placement of the blocks
 * @returns
 */
function getBlockPositionOnGrid(blockType, slotPosition, grid) {
    const blockSize = index_1.Block.getBlockSize(blockType); // Assume that width always be an odd number
    const halfWidth = (blockSize.width - 1) / 2;
    const isWideBlock = blockSize.width > 1;
    if (grid[grid.length - 1][slotPosition] !== 0) {
        throw Error('Height boundary is intruded.');
    }
    const allowPosition = { x: slotPosition, y: grid.length - 1 };
    for (let rowIndex = grid.length - 1; rowIndex >= 0; rowIndex--) {
        if (grid[rowIndex][slotPosition] !== 0) {
            break;
        }
        if (isWideBlock && !isSpaceEnoughForWideBlock(grid, rowIndex, slotPosition, halfWidth)) {
            break;
        }
        allowPosition.y = rowIndex;
    }
    return allowPosition;
}
exports.getBlockPositionOnGrid = getBlockPositionOnGrid;
/**
 * This function is used to check if there is enough space for a wide block on the grid
 * @param grid grid represents the placement of the blocks
 * @param rowIndex index of the row on the grid to check
 * @param slotPosition slot position of the block
 * @param halfWidth half width of the block
 * @returns
 */
function isSpaceEnoughForWideBlock(grid, rowIndex, slotPosition, halfWidth) {
    let isEmpty = true;
    // Check left and right side of a wide block that it is empty
    for (let j = 1; j <= halfWidth; j++) {
        const isBoundaryIntruded = slotPosition - j < 0 || slotPosition + j > grid[0].length - 1;
        if (isBoundaryIntruded) {
            throw Error('Width boundary is intruded.');
        }
        if (grid[rowIndex][slotPosition - j] !== 0 || grid[rowIndex][slotPosition + j] !== 0) {
            isEmpty = false;
            break;
        }
    }
    return isEmpty;
}
/**
 * This function is used to place a block on the grid
 * @param grid grid represents the placement of the blocks
 * @param allowPosition true position of the block on the grid
 * @param slotPosition slot position of the block
 * @param blockSize size of the block
 * @returns
 */
function placeBlockOnGrid(grid, allowPosition, slotPosition, blockSize) {
    const newGrid = grid.map((row) => [...row]);
    const isWideBlock = blockSize.width > 1;
    const isTallBlock = blockSize.height > 1;
    const halfWidth = (blockSize.width - 1) / 2;
    newGrid[allowPosition.y][slotPosition] = 1;
    if (isWideBlock) {
        for (let j = 1; j <= halfWidth; j++) {
            newGrid[allowPosition.y][slotPosition - j] = 1;
            newGrid[allowPosition.y][slotPosition + j] = 1;
        }
    }
    if (isTallBlock) {
        for (let j = 1; j < blockSize.height; j++) {
            const isBoundaryIntruded = allowPosition.y + j > grid.length - 1;
            if (isBoundaryIntruded) {
                throw Error('Height boundary is intruded.');
            }
            newGrid[allowPosition.y + j][slotPosition] = 1;
        }
    }
    return newGrid;
}
/**
 * This function is used to get the width of the grid part that contains blocks
 * @param grid grid represents the placement of the blocks
 * @returns the width of the grid part that contains blocks
 */
function getGridContentWidth(grid) {
    let temp = 0;
    for (const row of grid) {
        const rowSum = row.reduce((a, b) => a + b, 0);
        if (rowSum > temp) {
            temp = rowSum;
        }
    }
    const width = new bignumber_js_1.default(temp);
    return exports.STRUCTURE_STARTING_POSITION.x.abs().plus(width.multipliedBy(exports.ONE_CELL_WIDTH_IN_UNITY));
}
exports.getGridContentWidth = getGridContentWidth;
/**
 * This function is used to get the height of the grid part that contains blocks
 * @param grid grid represents the placement of the blocks
 * @returns the height of the grid part that contains blocks
 */
function getGridContentHeight(grid) {
    let previousNonEmpty = 0;
    for (let i = 0; i < grid.length; i++) {
        const row = grid[i];
        const rowSum = row.reduce((a, b) => a + b, 0);
        if (rowSum > 0) {
            previousNonEmpty = i;
        }
    }
    const height = new bignumber_js_1.default(previousNonEmpty + 1);
    return exports.STRUCTURE_STARTING_POSITION.y.abs().plus(height.multipliedBy(exports.ONE_CELL_WIDTH_IN_UNITY));
}
exports.getGridContentHeight = getGridContentHeight;
/**
 * This function is used to initialize the grid with the given width and height with 0
 * @param width width of the grid
 * @param height height of the grid
 * @returns a grid with the given width and height initialized with 0
 */
function initializeGrid(width, height) {
    const grid = [];
    for (let i = 0; i < height; i++) {
        grid.push([]);
        for (let j = 0; j < width; j++) {
            grid[i].push(0);
        }
    }
    return grid;
}
exports.initializeGrid = initializeGrid;
/**
 * This function is used to print the grid
 * @param grid grid represents the placement of the blocks
 * @returns a string representation of the grid
 */
function printGrid(grid) {
    let output = '';
    for (let i = grid.length - 1; i >= 0; i--) {
        const row = grid[i];
        for (const item of row) {
            output += item;
        }
        output += '\n';
    }
    console.log(output);
    return output;
}
exports.printGrid = printGrid;
