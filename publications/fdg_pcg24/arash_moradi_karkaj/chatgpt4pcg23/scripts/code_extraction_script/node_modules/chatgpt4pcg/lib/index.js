"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertTextToBlocks = exports.convertTextToXML = exports.containObjectTokens = exports.containDisallowedCharacters = exports.countWords = exports.extractCode = exports.BlockType = exports.Size = exports.Position = exports.Block = void 0;
const index_1 = require("./converter/models/index");
Object.defineProperty(exports, "Block", { enumerable: true, get: function () { return index_1.Block; } });
Object.defineProperty(exports, "BlockType", { enumerable: true, get: function () { return index_1.BlockType; } });
Object.defineProperty(exports, "Position", { enumerable: true, get: function () { return index_1.Position; } });
Object.defineProperty(exports, "Size", { enumerable: true, get: function () { return index_1.Size; } });
const xml_1 = require("./converter/xml");
const converter_1 = require("./converter/converter");
const words_count_1 = __importDefault(require("words-count"));
/**
 *  This function is used to extract `ab_drop` function calls from the text
 * @param text text containing `ab_drop` function calls
 * @returns a new string containing only the `ab_drop` function calls
 */
function extractCode(text) {
    const PATTERN = /```([^`]+)```/g;
    const CODE_PATTERN = /ab_drop\(['|"]b[1|3][1|3]['|"], *\d*\)/g;
    let match;
    let lastMatch = null;
    while ((match = PATTERN.exec(text)) !== null) {
        lastMatch = match;
    }
    if (!lastMatch) {
        return null;
    }
    const code = lastMatch[0];
    const functionCode = code.matchAll(CODE_PATTERN);
    let output = '';
    for (const fn of functionCode) {
        output += fn.toString().replaceAll('"', "'") + '\n';
    }
    if (output.length === 0) {
        return null;
    }
    return output.toLowerCase();
}
exports.extractCode = extractCode;
/**
 * This function is used to count words in the text
 * @param text text to count words in
 * @returns a number of words in the text
 */
function countWords(text) {
    return (0, words_count_1.default)(text);
}
exports.countWords = countWords;
/**
 * This function is used to check if the text contains disallowed characters
 * @param text text to check for disallowed characters
 * @returns true if the text contains disallowed characters, false otherwise
 */
function containDisallowedCharacters(text) {
    const PATTERN = /([A-Za-z\d~/\\+,\-*`'".!@#$%^&()_=[\]{}|<>:;?â€”\u201C\u201D\u2018\u2019 \n\r\t]*)*/g;
    return text.replaceAll(PATTERN, '').trim().length !== 0;
}
exports.containDisallowedCharacters = containDisallowedCharacters;
/**
 * This function is used to check if the text contains <OBJECT> tokens
 * @param text text to check for <OBJECT> tokens
 * @returns true if the text contains object tokens, false otherwise
 */
function containObjectTokens(text) {
    var _a;
    const PATTERN = /<OBJECT>/g;
    return (((_a = text.match(PATTERN)) === null || _a === void 0 ? void 0 : _a.length) || -1) > 0;
}
exports.containObjectTokens = containObjectTokens;
/**
 * This function is used to convert text of only `ab_drop()` functions to XML file used in Science Birds
 * @param text text of only `ab_drop()` functions to convert to XML
 * @returns XML file represents a level in the Science Birds
 */
function convertTextToXML(text) {
    return (0, xml_1.convertToXML)(text.toLowerCase());
}
exports.convertTextToXML = convertTextToXML;
/**
 * This function is used to convert text of only `ab_drop()` functions to an array of `Block`'s blocks with their positions on the grid
 * @param text text of only `ab_drop()` functions to convert to blocks
 * @returns an array of `Block`'s blocks with their positions on the grid
 */
function convertTextToBlocks(text) {
    return (0, converter_1.getBlocksWithPosition)(text.toLowerCase());
}
exports.convertTextToBlocks = convertTextToBlocks;
