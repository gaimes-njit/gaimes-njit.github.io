"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appendLog = exports.createLogFolder = exports.createResultOutputFolder = exports.createOutputFolder = exports.listCharactersDirs = exports.listAllFiles = exports.listAllDirs = exports.parseSourceFolderArgument = exports.LOG_FOLDER_NAME = exports.RESULT_FOLDER_NAME = void 0;
const fs_1 = __importDefault(require("fs"));
const minimist_1 = __importDefault(require("minimist"));
const path_1 = __importDefault(require("path"));
exports.RESULT_FOLDER_NAME = 'result';
exports.LOG_FOLDER_NAME = 'logs';
const START_TIME = new Date().toISOString().replaceAll(":", "_").replaceAll("/", "_");
/**
 * This function will parse source folder arguments from the command line
 * @returns a path to the source folder
 */
function parseSourceFolderArgument() {
    const args = (0, minimist_1.default)(process.argv.slice(2));
    const argv = process.platform === 'win32' ? args['_'] : args['s'];
    if (argv === undefined) {
        throw Error('Insufficient parameters to work with.');
    }
    return path_1.default.posix.resolve(argv + '/');
}
exports.parseSourceFolderArgument = parseSourceFolderArgument;
/**
 * This function will list all directories in the source folder
 * @param sourceFolderPath is a target folder to list all directories
 * @returns a list of directories
 */
function listAllDirs(sourceFolderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield fs_1.default.promises.readdir(sourceFolderPath);
        const directories = [];
        for (const file of files) {
            const fPath = path_1.default.posix.join(sourceFolderPath, file);
            const fileState = yield fs_1.default.promises.stat(fPath);
            if (fileState.isDirectory() && !file.startsWith('.') && file !== exports.LOG_FOLDER_NAME && file !== exports.RESULT_FOLDER_NAME) {
                directories.push(file);
            }
        }
        return directories;
    });
}
exports.listAllDirs = listAllDirs;
/**
 * This function will list all files in the source folder
 * @param sourceFolderPath is a target folder to list all files
 * @returns a list of files
 */
function listAllFiles(sourceFolderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield fs_1.default.promises.readdir(sourceFolderPath);
        const filesInDirectory = [];
        for (const file of files) {
            const fPath = path_1.default.posix.join(sourceFolderPath, file);
            const fileStat = yield fs_1.default.promises.stat(fPath);
            const isDirectory = fileStat.isDirectory();
            const fileName = file.split('/')[file.split('/').length - 1];
            if (!isDirectory && !fileName.startsWith('.')) {
                filesInDirectory.push(fileName);
            }
        }
        return filesInDirectory;
    });
}
exports.listAllFiles = listAllFiles;
/**
 * This function will list all characters (folder names) in the source folder
 * @param sourceFolderPath is a target folder to list all characters
 * @param stage is a stage name.
 * @returns a list of characters
 */
function listCharactersDirs(sourceFolderPath, stage) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = path_1.default.posix.join(sourceFolderPath, stage);
        const characters = yield listAllDirs(filePath);
        return characters;
    });
}
exports.listCharactersDirs = listCharactersDirs;
/**
 * This function will create output folders in the same structure as the source folder
 * @param sourceFolderPath is a path to the source folder
 * @param outputFolderName is a name of the output folder
 * @param stage is a stage name
 * @returns a path to the output folder
 */
function createOutputFolder(sourceFolderPath, outputFolderName, stage) {
    return __awaiter(this, void 0, void 0, function* () {
        const pathArr = sourceFolderPath.split('/');
        const root = pathArr.slice(0, pathArr.length - 3).join('/');
        const team = pathArr[pathArr.length - 3];
        const folders = sourceFolderPath.split('/').slice(pathArr.length - 2);
        const outputDir = path_1.default.posix.join(root, team, outputFolderName);
        if (!fs_1.default.existsSync(outputDir)) {
            yield fs_1.default.promises.mkdir(outputDir);
        }
        let currentDir = outputDir;
        for (const folder of folders) {
            if (folder === stage) {
                continue;
            }
            currentDir = path_1.default.posix.join(currentDir, folder);
            if (!fs_1.default.existsSync(currentDir)) {
                yield fs_1.default.promises.mkdir(currentDir);
            }
        }
        return currentDir;
    });
}
exports.createOutputFolder = createOutputFolder;
/**
 * This function will create a result folder in the source folder
 * @param sourceFolderPath is a path to the source folder
 * @returns a path to the result folder
 */
function createResultOutputFolder(sourceFolderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const outputDir = path_1.default.posix.join(sourceFolderPath, exports.RESULT_FOLDER_NAME);
        if (!fs_1.default.existsSync(outputDir)) {
            yield fs_1.default.promises.mkdir(outputDir);
        }
        return outputDir;
    });
}
exports.createResultOutputFolder = createResultOutputFolder;
/**
 * This function will create a log folder in the same structure as the source folder
 * @param sourceFolderPath is a path to the source folder
 * @returns a path to the log folder
 */
function createLogFolder(sourceFolderPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const outputDir = path_1.default.posix.join(sourceFolderPath, exports.LOG_FOLDER_NAME);
        if (!fs_1.default.existsSync(outputDir)) {
            fs_1.default.promises.mkdir(outputDir);
        }
        return outputDir;
    });
}
exports.createLogFolder = createLogFolder;
/**
 * This function will append a log to the log file and print it to the console
 * @param logFolderPath is a path to the log folder
 * @param stage is a stage name
 * @param log is a log message
 */
function appendLog(logFolderPath, stage, log) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(log);
        const logFilePath = path_1.default.posix.join(logFolderPath, `${stage}_log_${START_TIME}.txt`);
        if (!fs_1.default.existsSync(logFilePath)) {
            yield fs_1.default.promises.writeFile(logFilePath, '');
        }
        yield fs_1.default.promises.appendFile(logFilePath, `${log}\n`);
    });
}
exports.appendLog = appendLog;
