First, let's initialize the map with all cells set to zero. We can use a two-dimensional array to represent the map.

```
map = [[0 for _ in range(20)] for _ in range(16)]
```

Next, let's define a helper function called 'check_collision' to check if a specific position on the map is already occupied by a previously placed brick.

```python
def check_collision(x, y):
    return map[y][x] == 1
```

Now, let's define the 'ab_drop' function to handle the dropping of bricks.

```python
def ab_drop(x, y):
    if x == 'b11':
        brick = [[1]]
    elif x == 'b13':
        brick = [[1], [1], [1]]
    elif x == 'b31':
        brick = [[1, 1, 1]]
    else:
        return
    
    position = [y, 15]  # Starting position at the top of the field
    width = len(brick[0])
    height = len(brick)
    
    for i in range(height):
        for j in range(width):
            cell_x = y - 1 + j  # Calculate the x-axis position of the cell
            cell_y = 15 - (y + i)  # Calculate the y-axis position of the cell
            
            # Check for collision with previously placed bricks
            if position[1] + j >= 20 or check_collision(cell_x, cell_y):
                return
            
    # No collision detected, update the map with the new brick
    for i in range(height):
        for j in range(width):
            cell_x = y - 1 + j  # Calculate the x-axis position of the cell
            cell_y = 15 - (y + i)  # Calculate the y-axis position of the cell
            map[cell_y][cell_x] = 1
```

Finally, let's use the 'ab_drop' function to generate the shape resembling the letter "Q".

```python
ab_drop('b31', 5)
ab_drop('b13', 7)
ab_drop('b13', 12)
ab_drop('b13', 15)
ab_drop('b11', 14)
ab_drop('b11', 8)
```

After executing these functions, the map will contain the desired shape resembling the letter "Q".