To form a shape resembling the letter "D" using the given bricks and the ab_drop() function, we can follow these steps:

1. Initialize the map: Create a 2-dimensional array of size 16x20 to represent the field. Let's call it "map". Set all cells to 0 initially, indicating that they are unoccupied.

2. Place the "D" shape:
   - Drop a b13 brick at position (5, 12) using ab_drop('b13', 5). This will fill cells (5, 12), (5, 11), and (5, 10).
   - Drop a b11 brick at position (5, 9) using ab_drop('b11', 5). This will fill cell (5, 9).
   - Drop a b11 brick at position (5, 8) using ab_drop('b11', 5). This will fill cell (5, 8).
   - Drop a b11 brick at position (5, 7) using ab_drop('b11', 5). This will fill cell (5, 7).
   - Drop a b11 brick at position (5, 6) using ab_drop('b11', 5). This will fill cell (5, 6).
   - Drop a b11 brick at position (5, 5) using ab_drop('b11', 5). This will fill cell (5, 5).
   - Drop a b11 brick at position (5, 4) using ab_drop('b11', 5). This will fill cell (5, 4).
   - Drop a b11 brick at position (5, 3) using ab_drop('b11', 5). This will fill cell (5, 3).
   - Drop a b13 brick at position (5, 2) using ab_drop('b13', 5). This will fill cells (5, 2), (5, 1), and (5, 0).

3. Check for stability: After dropping each brick, check if the structure remains stable. To do this, iterate through each row from top to bottom and check the stability condition for each cell. If any instability is detected, adjust the placement of the bricks to ensure stability.

4. Avoid boundary collisions: During the placement of each brick, ensure that the occupied cells of the brick do not exceed the boundaries of the field. If a brick placement would exceed the boundaries, adjust the x_position parameter accordingly to fit the brick within the field.

Here is the code implementation:

```python
def ab_drop(x, y):
    if x == 'b31':
        width = 3
        height = 1
        cells = [(y-1, 0), (y, 0), (y+1, 0)]
    elif x == 'b13':
        width = 1
        height = 3
        cells = [(y, 0), (y, 1), (y, 2)]
    elif x == 'b11':
        width = 1
        height = 1
        cells = [(y, 0)]
    else:
        return
    
    # Check for boundary collision
    for cell in cells:
        if cell[0] < 0 or cell[0] >= 20 or cell[1] < 0 or cell[1] >= 16:
            return
    
    # Check for stability
    for cell in cells:
        if cell[0] > 0 and map[cell[1]][cell[0]-1] == 0:
            return
        if cell[0] < 19 and map[cell[1]][cell[0]+1] == 0:
            return
    
    # Drop the brick
    for cell in cells:
        map[cell[1]][cell[0]] = 1

# Initialize the map
map = [[0] * 20 for _ in range(16)]

# Place the "D" shape
ab_drop('b13', 5)
ab_drop('b11', 5)
ab_drop('b11', 5)
ab_drop('b11', 5)
ab_drop('b11', 5)
ab_drop('b11', 5)
ab_drop('b11', 5)
ab_drop('b11', 5)
ab_drop('b13', 5)

# Print the map
for row in map:
    for cell in row:
        print(cell, end=' ')
    print()
```

After executing the above code, you will see the map printed with 1s indicating the occupied cells of the "D" shape resembling structure. The cells occupied by the shape will form the letter "D".