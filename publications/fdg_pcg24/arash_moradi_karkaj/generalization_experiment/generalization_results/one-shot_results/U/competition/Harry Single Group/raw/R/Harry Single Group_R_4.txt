To form the shape resembling the letter "R", we can use the following sequence of ab_drop() function calls:

1. ab_drop('b31', 0) - This will place a b31 brick at x_position 0. The cells (0, 0), (1, 0), and (2, 0) will be occupied.

2. ab_drop('b31', 1) - This will place a b31 brick at x_position 1. The cells (1, 1), (2, 1), and (3, 1) will be occupied.

3. ab_drop('b31', 2) - This will place a b31 brick at x_position 2. The cells (2, 2), (3, 2), and (4, 2) will be occupied.

4. ab_drop('b13', 4) - This will place a b13 brick at x_position 4. The cells (4, 3), (4, 4), and (4, 5) will be occupied.

Note: We start placing the bricks from the bottom and move upwards to ensure stability. The sequence of ab_drop() function calls is designed to meet this requirement.

Here is the code to generate the required structure:

```python
# Map initialization
field = [[0 for _ in range(20)] for _ in range(16)]

# Function to check if a cell is within the boundaries of the field
def within_boundaries(x, y):
    return x >= 0 and x < 20 and y >= 0 and y < 16

# Function to check if a cell is occupied by a previously placed brick
def is_occupied(x, y):
    return field[y][x] == 1

# Function to place a brick on the field
def place_brick(x, y, brick_type):
    if brick_type == 'b31':
        for i in range(3):
            field[y][x+i] = 1
    elif brick_type == 'b13':
        for i in range(3):
            field[y+i][x] = 1
    elif brick_type == 'b11':
        field[y][x] = 1

# Function to drop a brick from the top and check for stability and collisions
def ab_drop(x, y):
    brick_type = x
    x_position = y

    # Drop the brick from the top
    while True:
        if brick_type == 'b31':
            for i in range(3):
                if not within_boundaries(x_position+i, 15) or is_occupied(x_position+i, 15):
                    place_brick(x_position, 15-i, brick_type)
                    return
        elif brick_type == 'b13':
            for i in range(3):
                if not within_boundaries(x_position, 15-i) or is_occupied(x_position, 15-i):
                    place_brick(x_position, 15-i+1, brick_type)
                    return
        elif brick_type == 'b11':
            if not within_boundaries(x_position, 15) or is_occupied(x_position, 15):
                place_brick(x_position, 15, brick_type)
                return

        # If no occupied cell is detected, move the brick down by one cell
        if brick_type == 'b31':
            x_position += 1
        elif brick_type == 'b13':
            x_position = x_position
        elif brick_type == 'b11':
            x_position = x_position

# Generate the required structure
ab_drop('b31', 0)
ab_drop('b31', 1)
ab_drop('b31', 2)
ab_drop('b13', 4)
```

The resulting field will have the shape resembling the letter "R" formed by the bricks placed using the ab_drop() function.